// Copyright © 2013 Galvanized Logic Inc.
// Use is governed by a FreeBSD license found in the LICENSE file.

package physics

// collision deals with knowing when something has hit something else.
// Currently the basics of allowing simple arbitrary shapes to collide
// is in place (but not really finished or working).
//
// References:
//     http://www.cs.cmu.edu/~baraff/pbm/rigid2.pdf
//     http://www.realtimerendering.com/intersections.html
//
// TODO fix the collision detection methods, they're unfinished, untested broken
//      crap for the most part. The long term intent is to find a physics engine
//      author, or port (not wrap) an open source physics engine like Bullet.
// TODO Likely split shapes into specific files once the proper design is in place.

import (
	"log"
	"math"
	"vu/math/lin"
)

// ===========================================================================

// Contact describes the contact point between two objects. It contains a
// contact normal vector, and a contect depth which allows the contacting
// objects to be separated if necessary.
//
// TODO ideally the normal is a separating normal, pretty sure this is not
// always the case.  Also it would be nice to return a single separating
// contact point in the case of multiple contacts in a collision.
//
// Contacts are generated by collisions and consumed by collision resolution.
type Contact struct {
	Normal lin.V3  // Normal vector at contact location.
	Depth  float32 // Penetration depth
	Bid    int     // Body identifier.
}

// Contact
// ===========================================================================
// sphere implementation.

// sphere describes a 3D perfectly round ball.  It is represented with a
// center and a radius.  Spheres are the easiest to work with as far as
// collisions go, but can take more triangles to draw as a 3D object.
type sphere struct {
	center *lin.V3
	radius float32
}

// newSphere returns a pointer to a new sphere object that is centered at
// point x, y, z with radius r.
func newSphere(x, y, z, r float32) *sphere {
	return &sphere{&lin.V3{x, y, z}, r}
}

// Volume conforms to the Shape interface.  The volume of a sphere is
//     4/3πr^3 (4 divided by 3 times PI times radius-cubed)
func (s *sphere) Volume() float32 {
	return 4 / 3 * math.Pi * s.radius * s.radius * s.radius
}

// Collide conforms to the Shape interface.
func (s *sphere) Collide(shape Shape) (contacts []*Contact) {
	shp := interface{}(shape)
	switch t := shp.(type) {
	case *sphere:
		sphere, _ := shp.(*sphere)
		return s.collideSphere(sphere)
	case *plane:
		plane, _ := shp.(*plane)
		return s.collidePlane(plane)
	case *abox:
		abox, _ := shp.(*abox)
		return s.collideAbox(abox)
	case *ray:
		ray, _ := shp.(*ray)
		return ray.collideSphere(s) // reverse
	default:
		log.Printf("Sphere cannot impact with %T", t)
	}
	return
}

// collideSphere gives the resulting point of collision between two spheres.
// The contact will be nil if the spheres did not touch.
func (s *sphere) collideSphere(sphere *sphere) (cons []*Contact) {
	distance := s.center.Dist(sphere.center)
	radii := s.radius + sphere.radius
	if distance > radii {
		return // spheres are not touching.
	}
	con := &Contact{}
	cons = []*Contact{con}
	if distance < 0 || lin.IsZero(distance) {

		// The sphere centers are at the same location.  One may be contained
		// in the other or they are identical spheres.
		con.Normal.X, con.Normal.Y, con.Normal.Z = 1, 0, 0
		con.Depth = radii
	} else {

		// The spheres are overlapping. Calculate the unit normal vector for the contact.
		d1 := 1 / distance
		con.Normal.X = (s.center.X - sphere.center.X) * d1
		con.Normal.Y = (s.center.Y - sphere.center.Y) * d1
		con.Normal.Z = (s.center.Z - sphere.center.Z) * d1
		con.Depth = radii - distance
	}
	return
}

// collidePlane gives the resulting point of collision between a sphere
// and a plane.  See:
//    http://mathworld.wolfram.com/HessianNormalForm.html
//
// The point to plane distance from a point x0 to a plane is given by:
//    D = n dot x0 + p
// where
//    n is the unit normal vector.
//    p is the distance from the plane to the origin.
//
// The points of impact list (contacts) contain zero or one points
// for sphere/planes. The points of impact list will be empty
// if the sphere is not touching the plane.
func (s *sphere) collidePlane(plane *plane) (cons []*Contact) {
	distance := s.center.Dot(plane.normal) + plane.dist
	depth := -distance + s.radius
	if lin.IsZero(depth) || depth > 0 {
		con := &Contact{}
		con.Normal.X = plane.normal.X
		con.Normal.Y = plane.normal.Y
		con.Normal.Z = plane.normal.Z
		con.Depth = depth
		return []*Contact{con}
	}
	return
}

// collideAbox collides a sphere with an axis-aligned-bounding-box.
// The collision algorithm is based on (and confirmed from other websites):
//     http://www.gamasutra.com/view/feature/131790/simple_intersection_tests_for_games.php?page=4
// However, the calculation of the contact normals and depth was added
// and is untested crap.
func (s *sphere) collideAbox(abox *abox) (cons []*Contact) {
	var diff, sqrd float32
	cens := []float32{s.center.X, s.center.Y, s.center.Z}
	mins := []float32{abox.x1, abox.y1, abox.z1}
	maxs := []float32{abox.x2, abox.y2, abox.z2}
	dt := [3]float32{}
	for cnt := 0; cnt < 3; cnt++ {

		// ensure that the min's and max's are correct.
		if mins[cnt] > maxs[cnt] {
			log.Printf("sphere:colllideAbox - incorrect abox")
			mins[cnt], maxs[cnt] = maxs[cnt], mins[cnt]
		}

		// find the square of the distance from the sphere to the box
		if cens[cnt] < mins[cnt] {
			diff = cens[cnt] - mins[cnt]
			sqrd += diff * diff // track total
			dt[cnt] += diff     // track per axis.
		} else if cens[cnt] > maxs[cnt] {
			diff = cens[cnt] - maxs[cnt]
			sqrd += diff * diff // track total
			dt[cnt] += diff     // track per axis.
		}
	}
	if sqrd > s.radius*s.radius {
		return // did not collide
	}
	con := &Contact{}
	cons = []*Contact{con}
	con.Normal.X, con.Normal.Y, con.Normal.Z = dt[0], dt[1], dt[2]
	con.Normal.Unit()
	if lin.IsZero(sqrd - s.radius*s.radius) {
		con.Depth = 0
	} else {
		dt[0] = float32(math.Abs(float64(dt[0])))
		dt[1] = float32(math.Abs(float64(dt[1])))
		dt[2] = float32(math.Abs(float64(dt[2])))
		con.Depth = dt[0] + dt[1] + dt[2]
	}
	return
}

// Bounce conforms to the Shape interface.
func (s *sphere) Bounce(shape Shape, contacts []*Contact, m1, m2 *motion) {
	c := contacts[0] // kludge. TODO properly implement collision resolution.
	shp := interface{}(shape)
	switch t := shp.(type) {
	case *sphere:
		sphere, _ := shp.(*sphere)
		s.bounceSphere(sphere, c, m1, m2)
	case *plane:
		plane, _ := shp.(*plane)
		s.bouncePlane(plane, c, m1, m2)
	case *abox:
		abox, _ := shp.(*abox)
		s.bounceAbox(abox, c, m1, m2)
	case *ray:
		ray, _ := shp.(*ray)
		ray.bounceSphere(s, c, m1, m2) // reverse
	default:
		log.Printf("collision.sphere.bounce: cannot resolve collision with %T", t)
	}
}

// bounceSphere currently ignores rotation. May eventually want this for
// proper simulations like billiards.
func (s1 *sphere) bounceSphere(s2 *sphere, contact *Contact, mo1, mo2 *motion) {
	if contact == nil {
		return
	}
	bounceConservingMomentum(mo1, mo2)
}

// bouncePlane is used to simulate a ball bouncing off a wall or floor.
// The plane is not expected to move so the ball converts its momentum
// to the direction is reflected about the contact normal with the plane.
func (s *sphere) bouncePlane(plane *plane, c *Contact, mo1, mo2 *motion) {
	if c == nil {
		return
	}
	bounceAgainstSolid(c, mo1)
}

// bounceAbox currently acts like a plane. The Abox is treated as immovable,
// so the sphere bounces against it.
func (s *sphere) bounceAbox(abox *abox, c *Contact, mo1, mo2 *motion) {
	if c == nil {
		return
	}
	bounceAgainstSolid(c, mo1)
}

// sphere
// ===========================================================================
// abox (axis-aligned-bounding-box) implementation.

// abox is an axis aligned bounding box. It is specified by two verticies
// where the other six verticies of the box are generated is such a way as
// to align the sides of the box with the X, Y, and Z axis.
// The verticies for the box are:
//    x1, y1, z1 - vertex 1 (minimum point of the box)
//    X2, Y1, Z1 |
//    X1, Y2, Z1 |
//    X2, Y2, Z1 |- generated
//    X1, Y1, Z2 |
//    X2, Y1, Z2 |
//    X1, Y2, Z2 |
//    x2, y2, z2 - vertex 2 (maximum point of the box)
type abox struct {
	x1, y1, z1 float32 // vertex 1 (min: bottom left)
	x2, y2, z2 float32 // vertex 2 (max: top right)
}

// newAbox creates an initialized axis aligned bounding box. Use the first
// point as the minimum (bottom left) and the second point as the maximum
// (top right).
func newAbox(x1, y1, z1, x2, y2, z2 float32) *abox {
	return &abox{x1, y1, z1, x2, y2, z2}
}

// Volume conforms to the Shape interface.  The volume of a box is:  h * w * l
func (a *abox) Volume() float32 {
	mag := (a.x2 - a.x1) * (a.y2 - a.y1) * (a.z2 - a.z1)
	return float32(math.Abs(float64(mag)))
}

// Collide conforms to the Shape interface. Abox to Abox tests are generally
// expected to be used in broadphase collision tests.
func (a *abox) Collide(shape Shape) (cons []*Contact) {
	shp := interface{}(shape)
	switch t := shp.(type) {
	case *sphere:
		sphere, _ := shp.(*sphere)
		return sphere.collideAbox(a) // use reverse
	case *ray:
		ray, _ := shp.(*ray)
		return ray.collideAbox(a) // use reverse
	case *abox:
		abox, _ := shp.(*abox)
		return a.collideAbox(abox)
	case *plane:
		plane, _ := shp.(*plane)
		return a.collidePlane(plane)
	default:
		log.Printf("Abox cannot collide with %T", t)
	}
	return
}

// collideAbox against another Abox.
func (a *abox) collideAbox(ab2 *abox) (cons []*Contact) {
	if a.x2 > ab2.x1 && a.x1 < ab2.x2 &&
		a.y2 > ab2.y1 && a.y1 < ab2.y2 &&
		a.z2 > ab2.z1 && a.z1 < ab2.z2 {

		// collision occurred.  The point of collision will be where the intersection
		// along one of the axis is at a minimum. Contact point calc adapted from:
		//     http://www.gamedev.net/topic/567310-platform-game-collision-detection/
		faceNormals := []lin.V3{
			lin.V3{-1, 0, 0}, // left
			lin.V3{1, 0, 0},  // right
			lin.V3{0, -1, 0}, // bottom
			lin.V3{0, 1, 0},  // top
			lin.V3{0, 0, -1}, // far
			lin.V3{0, 0, 1},  // near
		}
		distances := []float32{
			(ab2.x2 - a.x1), // distance of ab2 to a's left side.
			(a.x2 - ab2.x1), // distance of ab2 to a's right side.
			(ab2.y2 - a.y1), // distance of ab2 to a's bottom side.
			(a.y2 - ab2.y1), // distance of ab2 to a's top side.
			(ab2.z2 - a.z1), // distance of ab2 to a's far side.
			(a.z2 - ab2.z1), // distance of ab2 to a's near side.
		}
		con := &Contact{}
		for index, distance := range distances {
			if index == 0 || distance < con.Depth {
				con.Depth = distance
				con.Normal = faceNormals[index]
			}
		}
		cons = []*Contact{con}
	}
	return
}

// collideAbox against a plane.
func (a *abox) collidePlane(p *plane) (cons []*Contact) {
	// TODO Use Separating Axis Therom from:
	// http://zach.in.tu-clausthal.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index.html
	// see section Geometric Approach - Testing Boxes II

	// Could also store an Abox as a center and an extents vector.  This calculation may become easier.
	return
}

// Bounce conforms to the Shape interface.
func (a *abox) Bounce(s Shape, contacts []*Contact, m1, m2 *motion) {
	c := contacts[0] // kludge. TODO properly implement collision resolution.
	shape := interface{}(s)
	switch t := shape.(type) {
	case *sphere:
		sphere, _ := shape.(*sphere)
		sphere.bounceAbox(a, c, m1, m2) // use reverse
	default:
		log.Printf("Abox cannot resolve collision with %T", t)
	}
}

// abox
// ===========================================================================
// plane implementation.

// plane represents a flat surface or wall.  See:
//    http://mathworld.wolfram.com/HessianNormalForm.html
//
// Essentially a, b, c form a normal to the plane and d represents the
// distance from the origin.
type plane struct {
	normal *lin.V3 // unit normal of the plane
	dist   float32 // distance of plane from origin.
}

// newPlane ensures that the plane normal vector is a unit vector.
// and that the distance value is properly calculated based on a
// point on the plane.
func newPlane(a, b, c float32, x, y, z float32) *plane {
	normal := &lin.V3{a, b, c}
	normal.Unit()
	point := &lin.V3{x, y, z}
	return &plane{normal, -normal.Dot(point)}
}

// Volume conforms to the Shape interface. A plane has no volume so it
// always returns 0.
func (p *plane) Volume() float32 {
	return 0
}

// Collide conforms to the Shape interface.
func (p *plane) Collide(s Shape) (cons []*Contact) {
	shape := interface{}(s)
	switch t := shape.(type) {
	case *sphere:
		sphere, _ := shape.(*sphere)
		return sphere.collidePlane(p) // use reverse
	case *ray:
		ray, _ := shape.(*ray)
		return ray.collidePlane(p) // use reverse
	case *abox:
		abox, _ := shape.(*abox)
		return abox.collidePlane(p) // use reverse
	default:
		log.Printf("Plane cannot collide with %T", t)
	}
	return
}

// Bounce conforms to the Shape interface.
func (p *plane) Bounce(s Shape, contacts []*Contact, m1, m2 *motion) {
	c := contacts[0] // kludge. TODO properly implement collision resolution.
	shape := interface{}(s)
	switch t := shape.(type) {
	case *sphere:
		sphere, _ := shape.(*sphere)
		sphere.bouncePlane(p, c, m1, m2) // use reverse
	default:
		log.Printf("Plane cannot resolveCollision with %T", t)
	}
}

// plane
// ===========================================================================
// ray implementation.

// ray represents a line segment. A ray is composed of an origin and a
// direction. The equation for a ray (line) is
//    x = o + dl
// where
//    x are the points on the line
//    o is the origin of the line
//    d is the distance along line from starting point
//    l is the direction of line (a unit vector)
// See: http://en.wikipedia.org/wiki/Line–sphere_intersection
type ray struct {
	origin *lin.V3
	dir    *lin.V3
}

// newRay ensures that the direction vector is a unit vector.
func newRay(ox, oy, oz float32, dx, dy, dz float32) *ray {
	dir := lin.V3{dx, dy, dz}
	return &ray{&lin.V3{ox, oy, oz}, dir.Unit()}
}

// Volume conforms to the Shape interface. A ray has no volume so it
// always returns 0.
func (r *ray) Volume() float32 {
	return 0
}

// Collide conforms to the Shape interface.
func (r *ray) Collide(s Shape) (cons []*Contact) {
	shape := interface{}(s)
	switch t := shape.(type) {
	case *sphere:
		sphere, _ := shape.(*sphere)
		return r.collideSphere(sphere)
	case *plane:
		plane, _ := shape.(*plane)
		return r.collidePlane(plane)
	case *abox:
		abox, _ := shape.(*abox)
		return r.collideAbox(abox)
	default:
		log.Printf("collision.ray.collide: cannot collide with %s", t)
	}
	return
}

// collidePlane determines if ray has collided with a plane.
//    http://www.icepick66.co.uk/collison-detection-2-ray-plane
//
// TODO test (write test cases for this once this is needed).
func (r *ray) collidePlane(plane *plane) (cons []*Contact) {
	dot := plane.normal.Dot(r.dir)

	// check if ray is parallel to the plane. (right angled to the normal)
	if lin.IsZero(dot) {
		return // did not collide
	}
	pOrigin := plane.normal.Clone().Scale(plane.dist)
	distanceToPlane := pOrigin.Sub(r.origin)

	// diff is the amount needed to go to plane from ray origin.
	x := plane.normal.Dot(distanceToPlane)
	y := r.dir.Dot(plane.normal)
	diff := x / y

	// if negative, then the ray is behind the plane and did not collide.
	if diff < 0 {
		return // did not collide
	}
	con := &Contact{}
	cons = []*Contact{con}
	con.Normal.X = r.origin.X * diff
	con.Normal.Y = r.origin.Y * diff
	con.Normal.Z = r.origin.Z * diff
	con.Depth = diff
	return
}

// collideAbox determines if ray has collided with an axis aligned bounding box.
// See (and thanks to):
//    http://tog.acm.org/resources/GraphicsGems/gems/RayBox.c
//
// TODO test (write test cases for this once this is needed).
func (r *ray) collideAbox(abox *abox) (cons []*Contact) {
	DIM := 3
	LEFT, RIGHT, MID := 0, 1, 2
	minB := []float32{abox.x1, abox.y1, abox.z1}
	maxB := []float32{abox.x2, abox.y2, abox.z2}
	origin := []float32{r.origin.X, r.origin.Y, r.origin.Z}
	dir := []float32{r.dir.X, r.dir.Y, r.dir.Z}
	hit := []float32{0, 0, 0}

	inside := true
	maxT := []float32{0, 0, 0}
	candidatePlane := []float32{0, 0, 0}
	quadrant := []int{0, 0, 0}
	for cnt := 0; cnt < DIM; cnt++ {
		if origin[cnt] < minB[cnt] {
			quadrant[cnt] = LEFT
			candidatePlane[cnt] = minB[cnt]
			inside = false
		} else if origin[cnt] > maxB[cnt] {
			quadrant[cnt] = RIGHT
			candidatePlane[cnt] = maxB[cnt]
			inside = false
		} else {
			quadrant[cnt] = MID
		}
	}

	// ray origin is inside the bounding box
	if inside {
		con := &Contact{}
		cons = []*Contact{con}
		con.Normal.X = r.origin.X
		con.Normal.Y = r.origin.Y
		con.Normal.Z = r.origin.Z
		return
	}

	// Calculate T distances to candidate planes
	for cnt := 0; cnt < DIM; cnt++ {
		if quadrant[cnt] != MID && dir[cnt] != 0 {
			maxT[cnt] = (candidatePlane[cnt] - origin[cnt]) / dir[cnt]
		} else {
			maxT[cnt] = -1.
		}
	}

	// Get largest of the maxT's for final choice of intersection
	whichPlane := 0
	for cnt := 1; cnt < DIM; cnt++ {
		if maxT[whichPlane] < maxT[cnt] {
			whichPlane = cnt
		}
	}

	// check that the final candidate is actually inside box
	if maxT[whichPlane] < 0 {
		return // ray did not intersect abox.
	}
	for cnt := 0; cnt < DIM; cnt++ {
		if whichPlane != cnt {
			hit[cnt] = origin[cnt] + maxT[whichPlane]*dir[cnt]
			if hit[cnt] < minB[cnt] || hit[cnt] > maxB[cnt] {
				return // ray did not intersect abox.
			}
		} else {
			hit[cnt] = candidatePlane[cnt]
		}
	}

	// ray has hit box.
	con := &Contact{}
	cons = []*Contact{con}
	con.Normal.X = hit[0]
	con.Normal.Y = hit[1]
	con.Normal.Z = hit[2]
	return
}

// collideSphere gives the resulting point of collision between
// a ray and a sphere. See:
//    http://en.wikipedia.org/wiki/Line–sphere_intersection
//
// Calculate
//     (l dot (o-c))^2 - ((o-c) dot (o-c)) + r^2
// If it is:
//     < 0 : line does not intersect sphere.
//     = 0 : line intersects sphere at one point.
//     > 0 : line intersects sphere at two points.
//
// The points of impact list (contacts) only contain zero or one points
// for sphere/rays. The points of impact list will be empty
// if the sphere is not touching the ray.
func (ray *ray) collideSphere(s *sphere) (cons []*Contact) {
	oc := &lin.V3{} // vector from origin of ray to center of sphere
	oc.X = ray.origin.X - s.center.X
	oc.Y = ray.origin.Y - s.center.Y
	oc.Z = ray.origin.Z - s.center.Z
	b := ray.dir.Dot(oc)
	test := b*b - oc.Dot(oc) + s.radius*s.radius
	var depth float32
	if lin.IsZero(test) {
		// hit at one point
		depth = ray.dir.Dot(oc)
	} else if test > 0 {
		// hit at two points
		depth = ray.dir.Dot(oc) - test // closest
	} else {
		return // no hit
	}
	con := &Contact{}
	cons = []*Contact{con}
	con.Normal.X = ray.origin.X + ray.dir.X*depth - s.center.X
	con.Normal.Y = ray.origin.Y + ray.dir.Y*depth - s.center.Y
	con.Normal.Z = ray.origin.Z + ray.dir.Z*depth - s.center.Z
	con.Depth = depth
	return
}

// Bounce conforms to the Shape interface.
func (r *ray) Bounce(s Shape, contacts []*Contact, m1, m2 *motion) {
	c := contacts[0] // kludge. TODO properly implement collision resolution.
	shape := interface{}(s)
	switch t := shape.(type) {
	case *sphere:
		sphere, _ := shape.(*sphere)
		r.bounceSphere(sphere, c, m1, m2)
	default:
		log.Printf("collision.ray.bounce: cannot resolveCollision with %T", t)
	}
}

// bounceSphere imparts all (if there is any) motion of the ray to
// the sphere.  This can be used to simulate small fast moving things
// like bullets hitting large items.
func (r *ray) bounceSphere(sphere *sphere, c *Contact, mo1, mo2 *motion) {
	if c == nil {
		return
	}
	bounceTransferingMomentum(mo1, mo2)
}

// ray
// ===========================================================================
// collision resolution methods

// Resolving collisions often affects the colliding objects momentum.
// Momentum (p) is mass (m) times velocity (v).
//    p = mv
// The collision calculation (can) conserve momentum (blame Newton) such that
// the total momentum before the collision equals the total momentum after:
//    p1 + p2 = p1' + p2'
// Some loss can be simulated with a damping factor.

// Two objects with motion have hit each other.  Update both motions
// according to their masses and current velocities.  The new linear
// momementum is based upon the current momentums and the mass
// of the two colliding objects (from wikipedia on momentum).
func bounceConservingMomentum(mo1, mo2 *motion) {
	if mo1 != nil && mo2 != nil {
		m1, m2 := mo1.mass, mo2.mass
		mm := m1 + m2
		v1 := mo1.linearVelocity()
		v2 := mo2.linearVelocity()
		l1 := &lin.V3{}
		l1.X = m1 * (2*(m1-m2)/(mm)*v1.X + 2*m2/(mm)*v2.X)
		l1.Y = m1 * (2*(m1-m2)/(mm)*v1.Y + 2*m2/(mm)*v2.Y)
		l1.Z = m1 * (2*(m1-m2)/(mm)*v1.Z + 2*m2/(mm)*v2.Z)
		l2 := &lin.V3{}
		l2.X = m2 * (2*(m2-m1)/(mm)*v2.X + 2*m1/(mm)*v1.X)
		l2.Y = m2 * (2*(m2-m1)/(mm)*v2.Y + 2*m1/(mm)*v1.Y)
		l2.Z = m2 * (2*(m2-m1)/(mm)*v2.Z + 2*m1/(mm)*v1.Z)
		mo1.setLinearMomentum(l1)
		mo2.setLinearMomentum(l2)

		// TODO update direction based on collision normal
	}
}

// One object has hit a solid object at the point of contact.  It is going to
// bounce away in a fairly elastic manner.
func bounceAgainstSolid(c *Contact, mo1 *motion) {
	if mo1 != nil {
		lm := mo1.linearMomentum()
		dot := 2 * lm.Dot(&c.Normal)
		lm.X = (lm.X - dot*c.Normal.X) * 0.9
		lm.Y = (lm.Y - dot*c.Normal.Y) * 0.9
		lm.Z = (lm.Z - dot*c.Normal.Z) * 0.9
		mo1.setLinearMomentum(lm)
	}
}

// All momentum from mo2 is transferred to mo1, and mo2 just stops.
// An example would be a bullet hitting a large, but movable target.
func bounceTransferingMomentum(mo1, mo2 *motion) {
	m2 := mo2.linearMomentum()
	l1 := mo1.linearMomentum()
	l1.X += m2.X
	l1.Y += m2.Y
	l1.Z += m2.Z
	mo1.setLinearMomentum(l1)

	// The second momentum just stops as all its momentum has been transferred.
	mo2.setLinearMomentum(&lin.V3{0, 0, 0})
}
